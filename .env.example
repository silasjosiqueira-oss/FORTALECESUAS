# ðŸ”§ CÃ³digo Pronto - Melhorias CrÃ­ticas

Este arquivo contÃ©m cÃ³digo pronto para copiar e implementar as melhorias mais importantes.

---

## 1. Middleware de ValidaÃ§Ã£o Completo

### Arquivo: `src/middlewares/validation.js`

```javascript
const { body, param, query, validationResult } = require('express-validator');

/**
 * Middleware para processar erros de validaÃ§Ã£o
 */
const handleValidationErrors = (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({
            error: 'ValidaÃ§Ã£o falhou',
            errors: errors.array().map(err => ({
                field: err.param,
                message: err.msg,
                value: err.value
            }))
        });
    }
    next();
};

/**
 * Validador de CPF
 */
const isValidCPF = (cpf) => {
    cpf = cpf.replace(/[^\d]/g, '');

    if (cpf.length !== 11 || /^(\d)\1{10}$/.test(cpf)) {
        return false;
    }

    let soma = 0;
    for (let i = 0; i < 9; i++) {
        soma += parseInt(cpf.charAt(i)) * (10 - i);
    }
    let resto = 11 - (soma % 11);
    let digito1 = resto >= 10 ? 0 : resto;

    if (digito1 !== parseInt(cpf.charAt(9))) {
        return false;
    }

    soma = 0;
    for (let i = 0; i < 10; i++) {
        soma += parseInt(cpf.charAt(i)) * (11 - i);
    }
    resto = 11 - (soma % 11);
    let digito2 = resto >= 10 ? 0 : resto;

    return digito2 === parseInt(cpf.charAt(10));
};

/**
 * ValidaÃ§Ãµes para Atendimentos
 */
const validateAtendimento = [
    body('nomeCompleto')
        .trim()
        .notEmpty().withMessage('Nome completo Ã© obrigatÃ³rio')
        .isLength({ min: 3, max: 200 }).withMessage('Nome deve ter entre 3 e 200 caracteres')
        .matches(/^[a-zÃ¡Ã Ã¢Ã£Ã©Ã¨ÃªÃ­Ã¯Ã³Ã´ÃµÃ¶ÃºÃ§Ã±\s]+$/i).withMessage('Nome contÃ©m caracteres invÃ¡lidos'),

    body('cpf')
        .trim()
        .notEmpty().withMessage('CPF Ã© obrigatÃ³rio')
        .custom((value) => {
            if (!isValidCPF(value)) {
                throw new Error('CPF invÃ¡lido');
            }
            return true;
        }),

    body('telefone')
        .optional()
        .trim()
        .matches(/^\(?[1-9]{2}\)?\s?9?[0-9]{4}-?[0-9]{4}$/).withMessage('Telefone invÃ¡lido'),

    body('email')
        .optional()
        .trim()
        .isEmail().withMessage('Email invÃ¡lido')
        .normalizeEmail(),

    body('dataNascimento')
        .optional()
        .isISO8601().withMessage('Data de nascimento invÃ¡lida'),

    body('status')
        .optional()
        .isIn(['aguardando', 'em-andamento', 'concluido', 'cancelado']).withMessage('Status invÃ¡lido'),

    body('prioridade')
        .optional()
        .isIn(['baixa', 'normal', 'alta', 'urgente']).withMessage('Prioridade invÃ¡lida'),

    handleValidationErrors
];

/**
 * ValidaÃ§Ãµes para BenefÃ­cios
 */
const validateBeneficio = [
    body('nome')
        .trim()
        .notEmpty().withMessage('Nome Ã© obrigatÃ³rio')
        .isLength({ min: 3, max: 200 }).withMessage('Nome deve ter entre 3 e 200 caracteres'),

    body('cpf')
        .optional()
        .trim()
        .custom((value) => {
            if (value && !isValidCPF(value)) {
                throw new Error('CPF invÃ¡lido');
            }
            return true;
        }),

    body('nis')
        .optional()
        .trim()
        .matches(/^\d{11}$/).withMessage('NIS deve conter 11 dÃ­gitos'),

    body('situacao')
        .optional()
        .isIn(['Ativo', 'Suspenso', 'Cancelado', 'Em AnÃ¡lise', 'Concedido', 'Indeferido', 'Entregue', 'Pendente'])
        .withMessage('SituaÃ§Ã£o invÃ¡lida'),

    handleValidationErrors
];

/**
 * ValidaÃ§Ã£o de ID
 */
const validateId = [
    param('id')
        .isInt({ min: 1 }).withMessage('ID invÃ¡lido'),

    handleValidationErrors
];

/**
 * ValidaÃ§Ã£o de Query de PaginaÃ§Ã£o
 */
const validatePagination = [
    query('page')
        .optional()
        .isInt({ min: 1 }).withMessage('PÃ¡gina deve ser um nÃºmero maior que 0'),

    query('limit')
        .optional()
        .isInt({ min: 1, max: 100 }).withMessage('Limite deve estar entre 1 e 100'),

    handleValidationErrors
];

/**
 * SanitizaÃ§Ã£o de Input
 */
const sanitizeInput = (req, res, next) => {
    // Remove caracteres perigosos
    const sanitize = (obj) => {
        if (typeof obj === 'string') {
            return obj
                .replace(/<script[^>]*>.*?<\/script>/gi, '')
                .replace(/<[^>]+>/g, '')
                .trim();
        }
        if (typeof obj === 'object' && obj !== null) {
            for (let key in obj) {
                obj[key] = sanitize(obj[key]);
            }
        }
        return obj;
    };

    req.body = sanitize(req.body);
    req.query = sanitize(req.query);
    req.params = sanitize(req.params);

    next();
};

module.exports = {
    validateAtendimento,
    validateBeneficio,
    validateId,
    validatePagination,
    sanitizeInput,
    handleValidationErrors,
    isValidCPF
};
```

### Como usar:

```javascript
// No server.js ou routes
const { validateAtendimento, validateId, sanitizeInput } = require('./src/middlewares/validation');

// Aplicar sanitizaÃ§Ã£o globalmente
app.use(sanitizeInput);

// Usar nas rotas
app.post('/api/atendimentos',
    identifyTenant,
    authenticateToken,
    checkPermission('atendimentos', 'criar'),
    validateAtendimento,  // â† Adicionar aqui
    async (req, res) => {
        // req.body jÃ¡ estÃ¡ validado!
        // ...
    }
);

app.put('/api/atendimentos/:id',
    identifyTenant,
    authenticateToken,
    checkPermission('atendimentos', 'editar'),
    validateId,  // Valida o ID
    validateAtendimento,
    async (req, res) => {
        // ...
    }
);
```

---

## 2. Rate Limiter AvanÃ§ado

### Arquivo: `src/middlewares/rateLimiter.js`

```javascript
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const Redis = require('ioredis');

// Cliente Redis (opcional, fallback para memÃ³ria se nÃ£o disponÃ­vel)
let redisClient;
try {
    redisClient = new Redis({
        host: process.env.REDIS_HOST || 'localhost',
        port: process.env.REDIS_PORT || 6379,
        retryStrategy: () => null // NÃ£o tentar reconectar se falhar
    });
} catch (error) {
    console.warn('Redis nÃ£o disponÃ­vel, usando rate limit em memÃ³ria');
    redisClient = null;
}

/**
 * Rate limiter global
 */
const globalLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutos
    max: 500,
    message: {
        error: 'Muitas requisiÃ§Ãµes',
        message: 'Tente novamente em 15 minutos'
    },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
        return `global:${req.tenantId || 'no-tenant'}:${req.ip}`;
    },
    ...(redisClient && {
        store: new RedisStore({
            client: redisClient,
            prefix: 'rl:'
        })
    })
});

/**
 * Rate limiter para autenticaÃ§Ã£o
 */
const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 10, // 10 tentativas
    message: {
        error: 'Muitas tentativas de login',
        message: 'Tente novamente em 15 minutos'
    },
    skipSuccessfulRequests: true,
    keyGenerator: (req) => {
        const username = req.body?.username || req.body?.usuario || 'unknown';
        return `auth:${username}:${req.ip}`;
    },
    handler: (req, res) => {
        const username = req.body?.username || req.body?.usuario;
        logger.warn('Rate limit de autenticaÃ§Ã£o atingido', {
            username,
            ip: req.ip,
            userAgent: req.headers['user-agent']
        });

        res.status(429).json({
            error: 'Muitas tentativas de login',
            message: 'Sua conta foi temporariamente bloqueada. Tente novamente em 15 minutos.',
            retryAfter: 900
        });
    },
    ...(redisClient && {
        store: new RedisStore({
            client: redisClient,
            prefix: 'rl_auth:'
        })
    })
});

/**
 * Rate limiter por usuÃ¡rio
 */
const userLimiter = rateLimit({
    windowMs: 1 * 60 * 1000, // 1 minuto
    max: 100,
    keyGenerator: (req) => {
        if (req.user?.role === 'super_admin') {
            return null; // Super admin sem limite
        }
        return `user:${req.tenantId}:${req.user?.id || req.ip}`;
    },
    skip: (req) => req.user?.role === 'super_admin',
    handler: (req, res) => {
        logger.warn('Rate limit de usuÃ¡rio atingido', {
            user: req.user?.username,
            tenant: req.tenant?.nome_organizacao,
            ip: req.ip,
            path: req.path
        });

        res.status(429).json({
            error: 'Limite de requisiÃ§Ãµes excedido',
            message: 'VocÃª estÃ¡ fazendo muitas requisiÃ§Ãµes. Aguarde um momento.',
            retryAfter: 60
        });
    },
    ...(redisClient && {
        store: new RedisStore({
            client: redisClient,
            prefix: 'rl_user:'
        })
    })
});

/**
 * Rate limiter para operaÃ§Ãµes de escrita
 */
const writeLimiter = rateLimit({
    windowMs: 1 * 60 * 1000,
    max: 30, // 30 escritas por minuto
    keyGenerator: (req) => {
        return `write:${req.tenantId}:${req.user?.id || req.ip}`;
    },
    skip: (req) => req.user?.role === 'super_admin',
    message: {
        error: 'Limite de operaÃ§Ãµes de escrita excedido',
        message: 'Aguarde um momento antes de criar/editar mais registros'
    },
    ...(redisClient && {
        store: new RedisStore({
            client: redisClient,
            prefix: 'rl_write:'
        })
    })
});

/**
 * Rate limiter para operaÃ§Ãµes de leitura
 */
const readLimiter = rateLimit({
    windowMs: 1 * 60 * 1000,
    max: 200, // 200 leituras por minuto
    keyGenerator: (req) => {
        return `read:${req.tenantId}:${req.user?.id || req.ip}`;
    },
    skip: (req) => req.user?.role === 'super_admin',
    message: {
        error: 'Limite de consultas excedido',
        message: 'Aguarde um momento antes de fazer mais consultas'
    },
    ...(redisClient && {
        store: new RedisStore({
            client: redisClient,
            prefix: 'rl_read:'
        })
    })
});

/**
 * Rate limiter para operaÃ§Ãµes pesadas (relatÃ³rios, exportaÃ§Ãµes)
 */
const heavyLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutos
    max: 5, // 5 operaÃ§Ãµes pesadas
    keyGenerator: (req) => {
        return `heavy:${req.tenantId}:${req.user?.id}`;
    },
    skip: (req) => req.user?.role === 'super_admin',
    message: {
        error: 'Limite de operaÃ§Ãµes pesadas excedido',
        message: 'Aguarde alguns minutos antes de gerar outro relatÃ³rio ou exportaÃ§Ã£o'
    },
    ...(redisClient && {
        store: new RedisStore({
            client: redisClient,
            prefix: 'rl_heavy:'
        })
    })
});

module.exports = {
    globalLimiter,
    authLimiter,
    userLimiter,
    writeLimiter,
    readLimiter,
    heavyLimiter
};
```

### Como usar:

```javascript
// No server.js
const {
    globalLimiter,
    authLimiter,
    userLimiter,
    writeLimiter,
    readLimiter,
    heavyLimiter
} = require('./src/middlewares/rateLimiter');

// Global
app.use(globalLimiter);

// AutenticaÃ§Ã£o
app.post('/auth/login', authLimiter, ...);

// Por usuÃ¡rio (apÃ³s autenticaÃ§Ã£o)
app.use('/api/', userLimiter);

// OperaÃ§Ãµes de escrita
app.post('/api/atendimentos', writeLimiter, ...);
app.put('/api/atendimentos/:id', writeLimiter, ...);
app.delete('/api/atendimentos/:id', writeLimiter, ...);

// OperaÃ§Ãµes de leitura (menos restritivo)
app.get('/api/atendimentos', readLimiter, ...);
app.get('/api/atendimentos/:id', readLimiter, ...);

// OperaÃ§Ãµes pesadas
app.post('/api/relatorios/gerar', heavyLimiter, ...);
app.get('/api/exportar', heavyLimiter, ...);
```

---

## 3. Cache Manager com Redis

### Arquivo: `src/utils/cacheManager.js`

```javascript
const NodeCache = require('node-cache');
const Redis = require('ioredis');
const logger = require('./logger');

class CacheManager {
    constructor() {
        // L1 Cache: MemÃ³ria local (rÃ¡pido, mas limitado)
        this.l1Cache = new NodeCache({
            stdTTL: 60,
            checkperiod: 120,
            useClones: false,
            maxKeys: 1000
        });

        // L2 Cache: Redis (compartilhado entre instÃ¢ncias)
        try {
            this.l2Cache = new Redis({
                host: process.env.REDIS_HOST || 'localhost',
                port: process.env.REDIS_PORT || 6379,
                password: process.env.REDIS_PASSWORD,
                db: process.env.REDIS_DB || 0,
                retryStrategy: (times) => {
                    const delay = Math.min(times * 50, 2000);
                    return delay;
                },
                maxRetriesPerRequest: 3
            });

            this.l2Cache.on('connect', () => {
                logger.info('âœ… Redis conectado');
            });

            this.l2Cache.on('error', (err) => {
                logger.error('âŒ Erro no Redis', { error: err.message });
            });

            this.hasRedis = true;
        } catch (error) {
            logger.warn('Redis nÃ£o disponÃ­vel, usando apenas cache local', { error: error.message });
            this.l2Cache = null;
            this.hasRedis = false;
        }

        // EstatÃ­sticas
        this.stats = {
            hits: 0,
            misses: 0,
            l1Hits: 0,
            l2Hits: 0
        };
    }

    /**
     * Buscar valor do cache
     */
    async get(key) {
        try {
            // Tentar L1 primeiro (mais rÃ¡pido)
            const l1Value = this.l1Cache.get(key);
            if (l1Value !== undefined) {
                this.stats.hits++;
                this.stats.l1Hits++;
                logger.debug('Cache L1 hit', { key });
                return l1Value;
            }

            // Tentar L2 (Redis)
            if (this.hasRedis) {
                const l2Value = await this.l2Cache.get(key);
                if (l2Value) {
                    const parsed = JSON.parse(l2Value);

                    // Popular L1 com o valor encontrado
                    this.l1Cache.set(key, parsed);

                    this.stats.hits++;
                    this.stats.l2Hits++;
                    logger.debug('Cache L2 hit', { key });
                    return parsed;
                }
            }

            // Cache miss
            this.stats.misses++;
            logger.debug('Cache miss', { key });
            return null;

        } catch (error) {
            logger.error('Erro ao buscar do cache', { key, error: error.message });
            return null;
        }
    }

    /**
     * Salvar valor no cache
     */
    async set(key, value, ttl = 300) {
        try {
            // Salvar em L1
            this.l1Cache.set(key, value, ttl);

            // Salvar em L2 (Redis)
            if (this.hasRedis) {
                await this.l2Cache.setex(key, ttl, JSON.stringify(value));
            }

            logger.debug('Cache set', { key, ttl });
            return true;

        } catch (error) {
            logger.error('Erro ao salvar no cache', { key, error: error.message });
            return false;
        }
    }

    /**
     * Deletar valor do cache
     */
    async del(key) {
        try {
            // Deletar de L1
            this.l1Cache.del(key);

            // Deletar de L2
            if (this.hasRedis) {
                await this.l2Cache.del(key);
            }

            logger.debug('Cache deleted', { key });
            return true;

        } catch (error) {
            logger.error('Erro ao deletar do cache', { key, error: error.message });
            return false;
        }
    }

    /**
     * Deletar por padrÃ£o
     */
    async delPattern(pattern) {
        try {
            // L1: deletar keys que correspondem ao padrÃ£o
            const l1Keys = this.l1Cache.keys();
            const regex = new RegExp(pattern.replace('*', '.*'));
            l1Keys.filter(key => regex.test(key)).forEach(key => {
                this.l1Cache.del(key);
            });

            // L2: usar SCAN para evitar bloqueio
            if (this.hasRedis) {
                let cursor = '0';
                do {
                    const [newCursor, keys] = await this.l2Cache.scan(
                        cursor,
                        'MATCH',
                        pattern,
                        'COUNT',
                        100
                    );
                    cursor = newCursor;

                    if (keys.length > 0) {
                        await this.l2Cache.del(...keys);
                    }
                } while (cursor !== '0');
            }

            logger.info('Cache pattern deleted', { pattern });
            return true;

        } catch (error) {
            logger.error('Erro ao deletar pattern do cache', { pattern, error: error.message });
            return false;
        }
    }

    /**
     * Limpar todo o cache
     */
    async flush() {
        try {
            this.l1Cache.flushAll();

            if (this.hasRedis) {
                await this.l2Cache.flushdb();
            }

            logger.info('Cache limpo completamente');
            return true;

        } catch (error) {
            logger.error('Erro ao limpar cache', { error: error.message });
            return false;
        }
    }

    /**
     * Obter estatÃ­sticas
     */
    getStats() {
        const l1Stats = this.l1Cache.getStats();

        return {
            ...this.stats,
            hitRate: this.stats.hits / (this.stats.hits + this.stats.misses) || 0,
            l1: {
                keys: l1Stats.keys,
                hits: l1Stats.hits,
                misses: l1Stats.misses
            },
            l2: {
                available: this.hasRedis
            }
        };
    }

    /**
     * Wrapper para cache com fallback para funÃ§Ã£o
     */
    async wrap(key, fn, ttl = 300) {
        // Tentar buscar do cache
        let value = await this.get(key);

        if (value !== null) {
            return value;
        }

        // Cache miss: executar funÃ§Ã£o
        try {
            value = await fn();

            // Salvar no cache
            await this.set(key, value, ttl);

            return value;

        } catch (error) {
            logger.error('Erro ao executar funÃ§Ã£o com cache wrap', {
                key,
                error: error.message
            });
            throw error;
        }
    }
}

// Singleton
const cacheManager = new CacheManager();

module.exports = cacheManager;
```

### Como usar:

```javascript
// No server.js ou controllers
const cache = require('./src/utils/cacheManager');

// Exemplo 1: Cache simples
app.get('/api/atendimentos/:id', async (req, res) => {
    const cacheKey = `atendimento:${req.tenantId}:${req.params.id}`;

    // Tentar buscar do cache
    let atendimento = await cache.get(cacheKey);

    if (!atendimento) {
        // Cache miss: buscar do banco
        [atendimento] = await connection.query(
            'SELECT * FROM atendimentos WHERE id = ? AND tenant_id = ?',
            [req.params.id, req.tenantId]
        );

        // Salvar no cache por 5 minutos
        await cache.set(cacheKey, atendimento, 300);
    }

    res.json(atendimento);
});

// Exemplo 2: Cache wrap (mais limpo)
app.get('/api/atendimentos/:id', async (req, res) => {
    const atendimento = await cache.wrap(
        `atendimento:${req.tenantId}:${req.params.id}`,
        async () => {
            const [result] = await connection.query(
                'SELECT * FROM atendimentos WHERE id = ? AND tenant_id = ?',
                [req.params.id, req.tenantId]
            );
            return result[0];
        },
        300 // TTL de 5 minutos
    );

    res.json(atendimento);
});

// Invalidar cache ao atualizar
app.put('/api/atendimentos/:id', async (req, res) => {
    // Atualizar no banco
    await connection.query('UPDATE atendimentos SET ... WHERE id = ?', [req.params.id]);

    // Invalidar cache
    await cache.del(`atendimento:${req.tenantId}:${req.params.id}`);
    await cache.delPattern(`atendimentos:${req.tenantId}:*`); // Invalidar listagens

    res.json({ success: true });
});

// Verificar estatÃ­sticas do cache
app.get('/api/cache/stats', (req, res) => {
    const stats = cache.getStats();
    res.json(stats);
});
```

---

## 4. Environment Variables Checker

### Arquivo: `src/utils/envChecker.js`

```javascript
const logger = require('./logger');

/**
 * VariÃ¡veis obrigatÃ³rias
 */
const REQUIRED_VARS = [
    'NODE_ENV',
    'PORT',
    'JWT_SECRET',
    'DB_HOST',
    'DB_USER',
    'DB_PASSWORD',
    'DB_NAME'
];

/**
 * VariÃ¡veis recomendadas
 */
const RECOMMENDED_VARS = [
    'REDIS_HOST',
    'REDIS_PORT',
    'ADMIN_KEY',
    'METRICS_KEY',
    'LOG_LEVEL'
];

/**
 * Validar tamanho mÃ­nimo de secrets
 */
const SECRET_MIN_LENGTH = 32;

/**
 * Verificar variÃ¡veis de ambiente
 */
function checkEnvironment() {
    logger.info('ðŸ” Verificando variÃ¡veis de ambiente...');

    const missing = [];
    const weak = [];
    const recommended = [];

    // Verificar obrigatÃ³rias
    REQUIRED_VARS.forEach(varName => {
        if (!process.env[varName]) {
            missing.push(varName);
        } else if (varName.includes('SECRET') || varName.includes('PASSWORD')) {
            if (process.env[varName].length < SECRET_MIN_LENGTH) {
                weak.push(varName);
            }
        }
    });

    // Verificar recomendadas
    RECOMMENDED_VARS.forEach(varName => {
        if (!process.env[varName]) {
            recommended.push(varName);
        }
    });

    // Reportar problemas
    if (missing.length > 0) {
        logger.error('âŒ VariÃ¡veis obrigatÃ³rias faltando:', missing);
        logger.error('Configure as variÃ¡veis no arquivo .env');
        process.exit(1);
    }

    if (weak.length > 0) {
        logger.warn('âš ï¸  Secrets fracos detectados:', weak);
        logger.warn(`Recomendado: mÃ­nimo ${SECRET_MIN_LENGTH} caracteres`);

        if (process.env.NODE_ENV === 'production') {
            logger.error('âŒ Secrets fracos nÃ£o permitidos em produÃ§Ã£o');
            process.exit(1);
        }
    }

    if (recommended.length > 0) {
        logger.warn('âš ï¸  VariÃ¡veis recomendadas faltando:', recommended);
    }

    // Verificar NODE_ENV
    if (!['development', 'production', 'test'].includes(process.env.NODE_ENV)) {
        logger.warn('âš ï¸  NODE_ENV invÃ¡lido, usando "development"');
        process.env.NODE_ENV = 'development';
    }

    // Verificar fallbacks perigosos em produÃ§Ã£o
    if (process.env.NODE_ENV === 'production') {
        if (process.env.JWT_SECRET.includes('sua_chave_secreta')) {
            logger.error('âŒ JWT_SECRET com valor padrÃ£o em produÃ§Ã£o!');
            process.exit(1);
        }

        if (process.env.DB_PASSWORD === 'root' || process.env.DB_PASSWORD === 'password') {
            logger.error('âŒ Senha de banco muito fraca em produÃ§Ã£o!');
            process.exit(1);
        }
    }

    logger.info('âœ… VariÃ¡veis de ambiente validadas');

    return {
        valid: true,
        missing: [],
        weak: weak.length > 0 ? weak : [],
        recommended: recommended.length > 0 ? recommended : []
    };
}

module.exports = { checkEnvironment };
```

### Como usar:

```javascript
// No inÃ­cio do server.js, ANTES de tudo
require('dotenv').config();
const { checkEnvironment } = require('./src/utils/envChecker');

// Verificar ambiente
checkEnvironment();

// Continuar com o resto do servidor...
const express = require('express');
// ...
```

---

## 5. Exemplo de .env Completo

### Arquivo: `.env.example`

```bash
# ===============================
# AMBIENTE
# ===============================
NODE_ENV=development
PORT=3000
LOG_LEVEL=info

# ===============================
# SEGURANÃ‡A
# ===============================
# IMPORTANTE: Gerar com: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
JWT_SECRET=sua_chave_jwt_super_secreta_com_pelo_menos_32_caracteres
ADMIN_KEY=sua_chave_admin_super_secreta_com_pelo_menos_32_caracteres
METRICS_KEY=sua_chave_metrics_super_secreta_com_pelo_menos_32_caracteres

# ===============================
# BANCO DE DADOS
# ===============================
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=sua_senha_do_banco
DB_NAME=cras_multi_tenant
DB_CONNECTION_LIMIT=100

# ===============================
# REDIS (Cache)
# ===============================
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DB=0

# ===============================
# SMTP (Email)
# ===============================
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=seu_email@gmail.com
SMTP_PASSWORD=sua_senha_app
SMTP_FROM=noreply@fortalecesuas.com

# ===============================
# MONITORAMENTO
# ===============================
APM_SERVER_URL=http://localhost:8200
APM_SERVICE_NAME=cras-api
APM_ENVIRONMENT=development

# ===============================
# LIMITES
# ===============================
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX=500
RATE_LIMIT_AUTH_MAX=10

# ===============================
# ARQUIVO/UPLOAD
# ===============================
MAX_FILE_SIZE=10485760
UPLOAD_DIR=./uploads

# ===============================
# CORS
# ===============================
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:5173

# ===============================
# FEATURES (FLAGS)
# ===============================
ENABLE_CACHE=true
ENABLE_REDIS=true
ENABLE_APM=false
ENABLE_METRICS=true
```

---

## Resumo de InstalaÃ§Ã£o

```bash
# Instalar dependÃªncias necessÃ¡rias
npm install express-validator
npm install ioredis
npm install rate-limit-redis

# Opcional (mas recomendado)
npm install winston winston-daily-rotate-file
npm install helmet cors compression
npm install prom-client
npm install elastic-apm-node

# Dev dependencies
npm install --save-dev jest supertest nodemon eslint
```

---

## Ordem de ImplementaÃ§Ã£o Sugerida

1. âœ… **envChecker.js** - Validar ambiente (5 min)
2. âœ… **validation.js** - ValidaÃ§Ã£o robusta (30 min)
3. âœ… **rateLimiter.js** - Rate limiting melhorado (20 min)
4. âœ… **cacheManager.js** - Sistema de cache (45 min)
5. ðŸ”§ Adicionar Ã­ndices no banco de dados (10 min)
6. ðŸ”§ Refatorar rotas para arquivos separados (2 horas)
7. ðŸ§ª Adicionar testes (1-2 dias)

**Total estimado para melhorias crÃ­ticas: ~1 dia de trabalho**

---

Pronto para implementar! ðŸš€
