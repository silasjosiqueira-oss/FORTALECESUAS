const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const path = require('path');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const rateLimit = require('express-rate-limit');
const compression = require('compression');
const responseTime = require('response-time');
require('dotenv').config();

// Cache para tenants (evita queries repetidas)
const NodeCache = require('node-cache');
const tenantCache = new NodeCache({
    stdTTL: 300, // 5 minutos
    checkperiod: 60, // Verificar expira√ß√£o a cada 60s
    useClones: false // Melhor performance
});

// Importar m√≥dulos refatorados
const { connectDatabase, getConnection } = require('./src/config/database');
const logger = require('./src/utils/logger');

// Importar rotas existentes
const estoqueRoutes = require('./src/routes/estoque');
const agendaRoutes = require('./src/routes/agenda');
const adminRoutes = require('./src/routes/admin');
const tenantsRoutes = require('./src/routes/tenants');
const app = express();

// ==========================================
// M√âTRICAS E MONITORAMENTO
// ==========================================

// Armazenar estat√≠sticas de requisi√ß√µes
const requestStats = new Map();

// Middleware para coletar m√©tricas
app.use(responseTime((req, res, time) => {
    const route = req.route?.path || req.path;
    const key = `${req.method}:${route}`;
    const current = requestStats.get(key) || { count: 0, total: 0, errors: 0 };

    requestStats.set(key, {
        count: current.count + 1,
        total: current.total + time,
        avg: (current.total + time) / (current.count + 1),
        errors: res.statusCode >= 400 ? current.errors + 1 : current.errors,
        lastAccess: new Date()
    });

    // Log de requisi√ß√µes lentas (> 1 segundo)
    if (time > 1000) {
        logger.warn('Requisi√ß√£o lenta detectada', {
            method: req.method,
            path: req.path,
            time: Math.round(time),
            tenant: req.tenant?.nome_organizacao
        });
    }
}));

// ==========================================
// RATE LIMITING
// ==========================================

// Rate limit global (mais permissivo)
const globalLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutos
    max: 500, // 500 requisi√ß√µes por IP
    message: { error: 'Muitas requisi√ß√µes. Tente novamente em 15 minutos.' },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
        // Usar tenant + IP para melhor controle
        return `${req.tenantId || 'no-tenant'}-${req.ip}`;
    }
});

// Rate limit para autentica√ß√£o (mais restrito)
const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 10, // 10 tentativas de login
    message: { error: 'Muitas tentativas de login. Tente novamente em 15 minutos.' },
    skipSuccessfulRequests: true // N√£o conta requisi√ß√µes bem-sucedidas
});

// Rate limit para APIs (moderado)
const apiLimiter = rateLimit({
    windowMs: 1 * 60 * 1000, // 1 minuto
    max: 100, // 100 requisi√ß√µes por minuto
    message: { error: 'Limite de requisi√ß√µes excedido. Tente novamente em 1 minuto.' }
});

// ==========================================
// MIDDLEWARE MULTI-TENANT MELHORADO
// ==========================================

// Middleware para identificar o Tenant pelo subdom√≠nio (COM CACHE)
const identifyTenant = async (req, res, next) => {
    try {
        const host = req.hostname || req.headers.host?.split(':')[0];

        // Extrair subdom√≠nio
        const parts = host.split('.');
        let subdomain = null;

        // localhost:3000 ou IP direto = desenvolvimento
        if (host === 'localhost' || host.match(/^\d+\.\d+\.\d+\.\d+$/)) {
            subdomain = 'demo'; // Tenant padr√£o para desenvolvimento
            logger.info('[DEV] Modo desenvolvimento - usando tenant "demo"');
        }
        // Subdom√≠nio real: cliente.fortalecesuas.com
        else if (parts.length >= 3) {
            subdomain = parts[0];

            // Ignorar www e dom√≠nio principal
            if (subdomain === 'www' || subdomain === 'fortalecesuas') {
                return res.redirect('https://fortalecesuas.com/cadastro');
            }
        }
        // Dom√≠nio sem subdom√≠nio
        else {
            return res.status(400).json({
                error: 'Acesso inv√°lido. Use: https://seucliente.fortalecesuas.com'
            });
        }

        // *** CACHE: Tentar buscar do cache primeiro ***
        let tenant = tenantCache.get(subdomain);

        if (tenant) {
            logger.debug('Tenant carregado do cache', { subdomain, tenant: tenant.nome_organizacao });
        } else {
            // Buscar tenant no banco apenas se n√£o estiver no cache
            const connection = await getConnection();
            const [tenants] = await connection.query(
                `SELECT t.*,
                        COUNT(u.id) as usuarios_ativos,
                        DATEDIFF(t.data_vencimento, NOW()) as dias_restantes
                 FROM tenants t
                 LEFT JOIN usuarios u ON u.tenant_id = t.id AND u.ativo = TRUE
                 WHERE t.subdomain = ?
                 GROUP BY t.id`,
                [subdomain]
            );

            if (tenants.length === 0) {
                return res.status(404).json({
                    error: 'Organiza√ß√£o n√£o encontrada',
                    message: 'Entre em contato com o suporte ou verifique o endere√ßo.'
                });
            }

            tenant = tenants[0];

            // Armazenar no cache
            tenantCache.set(subdomain, tenant);
            logger.debug('Tenant armazenado no cache', { subdomain, tenant: tenant.nome_organizacao });
        }

        // Verificar status do tenant
        if (tenant.status === 'suspenso') {
            return res.status(403).json({
                error: 'Conta suspensa',
                message: 'Entre em contato com o suporte para regularizar.'
            });
        }

        if (tenant.status === 'cancelado') {
            return res.status(403).json({
                error: 'Conta cancelada',
                message: 'Esta organiza√ß√£o n√£o possui mais acesso ao sistema.'
            });
        }

        // Verificar vencimento
        if (tenant.dias_restantes < 0) {
            return res.status(402).json({
                error: 'Assinatura vencida',
                message: `Sua assinatura venceu h√° ${Math.abs(tenant.dias_restantes)} dias. Renove para continuar.`,
                dias_vencidos: Math.abs(tenant.dias_restantes)
            });
        }

        // Aviso de vencimento pr√≥ximo
        if (tenant.dias_restantes <= 7 && tenant.dias_restantes > 0) {
            res.set('X-Aviso-Vencimento', `Sua assinatura vence em ${tenant.dias_restantes} dias`);
        }

        // Anexar tenant ao request
        req.tenant = tenant;
        req.tenantId = tenant.id;

        logger.info('Tenant identificado', {
            tenant: tenant.nome_organizacao,
            subdomain,
            status: tenant.status,
            dias_restantes: tenant.dias_restantes
        });

        next();

    } catch (error) {
        logger.error('Erro ao identificar tenant', { error: error.message, stack: error.stack });
        res.status(500).json({
            error: 'Erro interno do servidor',
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
};

// Middleware de autentica√ß√£o JWT (MELHORADO)
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
        logger.warn('Token n√£o fornecido', {
            path: req.path,
            ip: req.ip,
            tenant: req.tenant?.nome_organizacao
        });
        return res.status(401).json({ error: 'Token n√£o fornecido' });
    }

    jwt.verify(token, process.env.JWT_SECRET || 'sua_chave_secreta_muito_segura', (err, decoded) => {
        if (err) {
            logger.warn('Token inv√°lido ou expirado', {
                error: err.message,
                path: req.path,
                tenant: req.tenant?.nome_organizacao
            });
            return res.status(403).json({ error: 'Token inv√°lido ou expirado' });
        }

        // Verificar se o token pertence ao tenant correto
        if (req.tenantId && decoded.tenantId !== req.tenantId) {
            logger.error('Tentativa de acesso cross-tenant', {
                tokenTenant: decoded.tenantId,
                requestTenant: req.tenantId,
                user: decoded.usuario
            });
            return res.status(403).json({ error: 'Token n√£o pertence a esta organiza√ß√£o' });
        }

        req.user = decoded;
        next();
    });
};

// ‚úÖ NOVO: Middleware para verificar Super Admin
const authenticateSuperAdmin = (req, res, next) => {
    // Verificar se usu√°rio est√° autenticado
    if (!req.user) {
        return res.status(401).json({
            error: 'Autentica√ß√£o necess√°ria',
            message: 'Fa√ßa login para continuar'
        });
    }

    // Verificar se √© super admin pelo perfil/n√≠vel
    if (req.user.perfil !== 'super_admin' && req.user.nivel_acesso !== 'super_admin') {
        logger.warn('Tentativa de acesso super admin negada', {
            user: req.user.username,
            perfil: req.user.perfil,
            path: req.path
        });
        return res.status(403).json({
            error: 'Acesso negado',
            message: 'Apenas Super Administradores podem acessar este recurso'
        });
    }

    // ‚úÖ Super admin verificado
    logger.info('Acesso super admin autorizado', {
        user: req.user.username,
        path: req.path
    });

    next();
};

// Middleware para verificar permiss√µes (OTIMIZADO)
const checkPermission = (recurso, acao) => {
    return async (req, res, next) => {
        try {
            if (!req.user) {
                return res.status(401).json({ error: 'Usu√°rio n√£o autenticado' });
            }

            // Admin e Super Admin t√™m todas as permiss√µes
            if (req.user.perfil === 'admin' || req.user.perfil === 'super_admin') {
                return next();
            }

            // Cache de permiss√µes por perfil (5 minutos)
            const cacheKey = `perm_${req.user.perfil}_${recurso}_${acao}`;
            let hasPermission = tenantCache.get(cacheKey);

            if (hasPermission === undefined) {
                const connection = await getConnection();
                const [permissoes] = await connection.query(
                    `SELECT p.* FROM permissoes p
                     WHERE p.perfil = ? AND p.recurso = ? AND p.acao = ? AND p.permitido = TRUE`,
                    [req.user.perfil, recurso, acao]
                );

                hasPermission = permissoes.length > 0;
                tenantCache.set(cacheKey, hasPermission, 300); // 5 minutos
            }

            if (!hasPermission) {
                logger.warn('Acesso negado - sem permiss√£o', {
                    user: req.user.username,
                    perfil: req.user.perfil,
                    recurso,
                    acao
                });
                return res.status(403).json({
                    error: 'Sem permiss√£o',
                    message: `Voc√™ n√£o tem permiss√£o para ${acao} em ${recurso}`
                });
            }

            next();
        } catch (error) {
            logger.error('Erro ao verificar permiss√µes', { error: error.message });
            res.status(500).json({ error: 'Erro ao verificar permiss√µes' });
        }
    };
};

// ==========================================
// CONFIGURA√á√ïES B√ÅSICAS
// ==========================================

// Compression para reduzir tamanho das respostas
app.use(compression());

// Helmet para seguran√ßa
app.use(helmet({
    contentSecurityPolicy: false,
    crossOriginEmbedderPolicy: false
}));

// ‚úÖ CORS CORRIGIDO (n√£o permite mais tudo)
const corsOptions = {
    origin: function(origin, callback) {
        // Lista de origens permitidas
        const allowedOrigins = [
            /\.fortalecesuas\.com$/,
            'http://localhost:3000',
            'http://localhost:5173',
            'http://localhost:8080',
            'http://127.0.0.1:3000',
            'http://127.0.0.1:5173'
        ];

        // Permitir requisi√ß√µes sem origin (Postman, mobile apps, etc)
        if (!origin) return callback(null, true);

        // Verificar se a origem est√° permitida
        const isAllowed = allowedOrigins.some(pattern =>
            typeof pattern === 'string' ? pattern === origin : pattern.test(origin)
        );

        if (isAllowed || process.env.NODE_ENV === 'development') {
            callback(null, true);
        } else {
            logger.warn('Origem CORS bloqueada', { origin });
            // ‚úÖ CORRIGIDO: Agora bloqueia de verdade
            callback(new Error('Origem n√£o permitida pelo CORS'));
        }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
    allowedHeaders: [
        'Content-Type',
        'Authorization',
        'X-CSRF-Token',
        'X-Requested-With',
        'X-Super-Admin-Key'
    ]
};

app.use(cors(corsOptions));

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Aplicar rate limiting global
app.use(globalLimiter);

// ==========================================
// SERVIR ARQUIVOS EST√ÅTICOS (ANTES DE TUDO!)
// ==========================================

// Middleware para configurar MIME types corretos
app.use((req, res, next) => {
    if (req.url.endsWith('.css')) {
        res.setHeader('Content-Type', 'text/css; charset=utf-8');
    } else if (req.url.endsWith('.js')) {
        res.setHeader('Content-Type', 'application/javascript; charset=utf-8');
    } else if (req.url.endsWith('.json')) {
        res.setHeader('Content-Type', 'application/json; charset=utf-8');
    }
    next();
});

// Servir arquivos est√°ticos (SEM middleware de tenant)
app.use('/css', express.static(path.join(__dirname, 'css'), {
    setHeaders: (res, filepath) => {
        if (filepath.endsWith('.css')) {
            res.setHeader('Content-Type', 'text/css');
        }
    }
}));

app.use('/src', express.static(path.join(__dirname, 'src')));
app.use('/js', express.static(path.join(__dirname, 'js')));
app.use('/img', express.static(path.join(__dirname, 'img')));
app.use('/pages', express.static(path.join(__dirname, 'pages')));

// ==========================================
// ROTAS P√öBLICAS (SEM AUTENTICA√á√ÉO)
// ==========================================

// Rota de cadastro (SEM tenant - p√°gina p√∫blica)
app.get('/cadastro', (req, res) => {
    res.sendFile(path.join(__dirname, 'pages', 'cadastro.html'));
});

// Health check melhorado
app.get('/health', async (req, res) => {
    try {
        const connection = await getConnection();
        await connection.query('SELECT 1');

        const uptime = process.uptime();
        const memory = process.memoryUsage();

        res.json({
            status: 'healthy',
            timestamp: new Date().toISOString(),
            uptime: `${Math.floor(uptime / 60)}m ${Math.floor(uptime % 60)}s`,
            database: 'connected',
            cache: {
                tenants: tenantCache.keys().length,
                stats: tenantCache.getStats()
            },
            memory: {
                rss: `${Math.round(memory.rss / 1024 / 1024)}MB`,
                heapUsed: `${Math.round(memory.heapUsed / 1024 / 1024)}MB`,
                heapTotal: `${Math.round(memory.heapTotal / 1024 / 1024)}MB`
            },
            environment: process.env.NODE_ENV || 'development'
        });
    } catch (error) {
        logger.error('Health check falhou', { error: error.message });
        res.status(503).json({
            status: 'unhealthy',
            timestamp: new Date().toISOString(),
            database: 'disconnected',
            error: process.env.NODE_ENV === 'development' ? error.message : 'Database error'
        });
    }
});

// Endpoint de m√©tricas (protegido)
app.get('/metrics', (req, res) => {
    const apiKey = req.headers['x-metrics-key'];

    if (apiKey !== process.env.METRICS_KEY && process.env.NODE_ENV === 'production') {
        return res.status(401).json({ error: 'Unauthorized' });
    }

    const metrics = Array.from(requestStats.entries()).map(([route, data]) => ({
        route,
        requests: data.count,
        avgTime: Math.round(data.avg),
        totalTime: Math.round(data.total),
        errors: data.errors,
        errorRate: data.count > 0 ? ((data.errors / data.count) * 100).toFixed(2) + '%' : '0%',
        lastAccess: data.lastAccess
    }));

    // Ordenar por n√∫mero de requisi√ß√µes
    metrics.sort((a, b) => b.requests - a.requests);

    res.json({
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        totalRequests: Array.from(requestStats.values()).reduce((sum, stat) => sum + stat.count, 0),
        cache: tenantCache.getStats(),
        routes: metrics
    });
});

// Limpar cache (apenas em desenvolvimento ou com chave especial)
app.post('/api/cache/clear', (req, res) => {
    const apiKey = req.headers['x-admin-key'];

    if (apiKey !== process.env.ADMIN_KEY && process.env.NODE_ENV === 'production') {
        return res.status(401).json({ error: 'Unauthorized' });
    }

    const keys = tenantCache.keys();
    tenantCache.flushAll();

    logger.info('Cache limpo manualmente', { keysCleared: keys.length });

    res.json({
        success: true,
        message: 'Cache limpo com sucesso',
        keysCleared: keys.length
    });
});

// ==========================================
// AUTENTICA√á√ÉO (COM RATE LIMITING ESPECIAL)
// ==========================================

// Login com rate limiting mais restrito
app.post('/auth/login', authLimiter, identifyTenant, async (req, res) => {
    try {
        const { usuario, senha } = req.body;

        if (!usuario || !senha) {
            return res.status(400).json({ error: 'Usu√°rio e senha s√£o obrigat√≥rios' });
        }

        const connection = await getConnection();
        const [usuarios] = await connection.query(
            `SELECT u.*, t.nome_organizacao, t.status as tenant_status,
                    na.codigo as nivel_acesso_codigo, na.nome as nivel_acesso_nome
             FROM usuarios u
             INNER JOIN tenants t ON t.id = u.tenant_id
             LEFT JOIN niveis_acesso na ON na.codigo = u.nivel_acesso_codigo
             WHERE (u.username = ? OR u.email = ?) AND u.tenant_id = ? AND u.ativo = TRUE`,
            [usuario, usuario, req.tenantId]
        );

        if (usuarios.length === 0) {
            logger.warn('Tentativa de login com usu√°rio inv√°lido', {
                usuario,
                tenant: req.tenant.nome_organizacao,
                ip: req.ip
            });
            return res.status(401).json({ error: 'Usu√°rio ou senha inv√°lidos' });
        }

        const user = usuarios[0];

        const senhaValida = await bcrypt.compare(senha, user.senha_hash);

        if (!senhaValida) {
            logger.warn('Tentativa de login com senha inv√°lida', {
                usuario,
                tenant: req.tenant.nome_organizacao,
                ip: req.ip
            });
            return res.status(401).json({ error: 'Usu√°rio ou senha inv√°lidos' });
        }

        // ‚úÖ Incluir n√≠vel de acesso no token
        const token = jwt.sign(
            {
                id: user.id,
                username: user.username,
                perfil: user.perfil || user.nivel_acesso_codigo,
                nivel_acesso: user.nivel_acesso_codigo,
                tenantId: req.tenantId,
                nomeOrganizacao: user.nome_organizacao
            },
            process.env.JWT_SECRET || 'sua_chave_secreta_muito_segura',
            { expiresIn: '8h' }
        );

        // Atualizar √∫ltimo acesso
        await connection.query(
            'UPDATE usuarios SET ultimo_acesso = NOW() WHERE id = ?',
            [user.id]
        );

        logger.info('Login bem-sucedido', {
            username: user.username,
            perfil: user.perfil || user.nivel_acesso_codigo,
            tenant: req.tenant.nome_organizacao
        });

        res.json({
            sucesso: true,
            token,
            usuario: {
                id: user.id,
                username: user.username,
                nome: user.nome_completo,
                email: user.email,
                perfil: user.perfil || user.nivel_acesso_codigo,
                nivel_acesso: user.nivel_acesso_codigo,
                organizacao: user.nome_organizacao
            }
        });

    } catch (error) {
        logger.error('Erro no login', { error: error.message, stack: error.stack });
        res.status(500).json({ error: 'Erro ao fazer login' });
    }
});

// Verificar token
app.get('/auth/verificar', identifyTenant, authenticateToken, (req, res) => {
    res.json({
        valido: true,
        usuario: req.user
    });
});

// Logout
app.post('/auth/logout', identifyTenant, authenticateToken, (req, res) => {
    logger.info('Logout', {
        usuario: req.user.username,
        tenant: req.tenant.nome_organizacao
    });
    res.json({ sucesso: true, mensagem: 'Logout realizado' });
});

// ==========================================
// P√ÅGINA INICIAL (COM TENANT)
// ==========================================

app.get('/', identifyTenant, (req, res) => {
    res.sendFile(path.join(__dirname, 'pages', 'index.html'));
});

// ==========================================
// ROTAS DE ATENDIMENTO (MANTIDAS EXATAMENTE COMO ESTAVAM)
// ==========================================

// Listar atendimentos
app.get('/api/atendimentos', identifyTenant, authenticateToken, async (req, res) => {
    try {
        const { dataInicio, dataFim, status, tecnico, busca, cpf, page = 1, limit = 50 } = req.query;

        let query = `
            SELECT
                a.*,
                DATE_FORMAT(a.data_atendimento, '%d/%m/%Y') as data_formatada
            FROM atendimentos a
            WHERE a.tenant_id = ?
        `;
        const params = [req.tenantId];

        // NOVO: Filtro espec√≠fico por CPF
        if (cpf) {
            const cpfLimpo = cpf.replace(/\D/g, ''); // Remove formata√ß√£o
            query += ' AND a.cpf = ?';
            params.push(cpfLimpo);
        }

        if (dataInicio) {
            query += ' AND a.data_atendimento >= ?';
            params.push(dataInicio);
        }
        if (dataFim) {
            query += ' AND a.data_atendimento <= ?';
            params.push(dataFim);
        }
        if (status) {
            query += ' AND a.status = ?';
            params.push(status);
        }
        if (tecnico) {
            query += ' AND a.tecnico_responsavel = ?';
            params.push(tecnico);
        }
        if (busca) {
            query += ' AND (a.nome_completo LIKE ? OR a.cpf LIKE ? OR a.telefone LIKE ?)';
            const buscaTermo = `%${busca}%`;
            params.push(buscaTermo, buscaTermo, buscaTermo);
        }

        query += ' ORDER BY a.data_atendimento DESC, a.hora_atendimento DESC';

        const offset = (parseInt(page) - 1) * parseInt(limit);
        query += ' LIMIT ? OFFSET ?';
        params.push(parseInt(limit), offset);

        const connection = await getConnection();
        const [atendimentos] = await connection.query(query, params);

        // CORRIGIDO: Aplicar os mesmos filtros no contador de total
        let countQuery = 'SELECT COUNT(*) as total FROM atendimentos a WHERE a.tenant_id = ?';
        const countParams = [req.tenantId];

        // NOVO: Incluir CPF no count tamb√©m
        if (cpf) {
            const cpfLimpo = cpf.replace(/\D/g, '');
            countQuery += ' AND a.cpf = ?';
            countParams.push(cpfLimpo);
        }

        if (dataInicio) {
            countQuery += ' AND a.data_atendimento >= ?';
            countParams.push(dataInicio);
        }
        if (dataFim) {
            countQuery += ' AND a.data_atendimento <= ?';
            countParams.push(dataFim);
        }
        if (status) {
            countQuery += ' AND a.status = ?';
            countParams.push(status);
        }
        if (tecnico) {
            countQuery += ' AND a.tecnico_responsavel = ?';
            countParams.push(tecnico);
        }
        if (busca) {
            countQuery += ' AND (a.nome_completo LIKE ? OR a.cpf LIKE ? OR a.telefone LIKE ?)';
            const buscaTermo = `%${busca}%`;
            countParams.push(buscaTermo, buscaTermo, buscaTermo);
        }

        const [[{ total }]] = await connection.query(countQuery, countParams);

        res.json({
            sucesso: true,
            atendimentos,
            paginacao: {
                total,
                pagina: parseInt(page),
                limite: parseInt(limit),
                totalPaginas: Math.ceil(total / parseInt(limit))
            }
        });

    } catch (error) {
        logger.error('Erro ao listar atendimentos', { error: error.message });
        res.status(500).json({ error: 'Erro ao buscar atendimentos' });
    }
});

// Buscar atendimento espec√≠fico
app.get('/api/atendimentos/:id', identifyTenant, authenticateToken, async (req, res) => {
    try {
        const connection = await getConnection();
        const [atendimentos] = await connection.query(
            `SELECT a.*,
                    DATE_FORMAT(a.data_atendimento, '%d/%m/%Y') as data_formatada
             FROM atendimentos a
             WHERE a.id = ? AND a.tenant_id = ?`,
            [req.params.id, req.tenantId]
        );

        if (atendimentos.length === 0) {
            return res.status(404).json({ error: 'Atendimento n√£o encontrado' });
        }

        res.json({ sucesso: true, atendimento: atendimentos[0] });

    } catch (error) {
        logger.error('Erro ao buscar atendimento', { error: error.message, id: req.params.id });
        res.status(500).json({ error: 'Erro ao buscar atendimento' });
    }
});

// Criar atendimento
app.post('/api/atendimentos', identifyTenant, authenticateToken, async (req, res) => {
    try {
        const dados = req.body;

        // Valida√ß√£o b√°sica
        if (!dados.nomeCompleto || !dados.cpf) {
            return res.status(400).json({
                error: 'Dados obrigat√≥rios faltando',
                campos: ['nomeCompleto', 'cpf']
            });
        }

        const connection = await getConnection();

        // Gerar registro no formato: 2025-0001, 2025-0002, etc.
        const ano = new Date().getFullYear();

        // Buscar o √∫ltimo n√∫mero de registro do ano atual
        const [ultimoRegistro] = await connection.query(
            `SELECT registro FROM atendimentos
             WHERE tenant_id = ? AND registro LIKE ?
             ORDER BY id DESC LIMIT 1`,
            [req.tenantId, `${ano}-%`]
        );

        let numeroSequencial = 1;
        if (ultimoRegistro.length > 0 && ultimoRegistro[0].registro) {
            // Extrair o n√∫mero do √∫ltimo registro (ex: "2025-0042" -> 42)
            const match = ultimoRegistro[0].registro.match(/\d{4}-(\d+)/);
            if (match && match[1]) {
                numeroSequencial = parseInt(match[1]) + 1;
            }
        }

        // Formatar com zeros √† esquerda (ex: 0001, 0042, 1234)
        const registro = `${ano}-${String(numeroSequencial).padStart(4, '0')}`;

        const [result] = await connection.query(
            `INSERT INTO atendimentos (
                tenant_id, usuario_id, registro, data_atendimento, hora_atendimento,
                nome_completo, cpf, telefone, data_nascimento,
                tecnico_responsavel, tipo_atendimento, unidade,
                status, prioridade, dados_completos
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
                req.tenantId,
                req.user.id,
                registro,
                dados.dataAtendimento || null,
                dados.horaAtendimento || null,
                dados.nomeCompleto,
                dados.cpf,
                dados.telefone,
                dados.dataNascimento || null,
                dados.tecnicoResponsavel,
                dados.tipoAtendimento || 'Atendimento Geral',
                dados.unidade || 'Secretaria',
                dados.status || 'aguardando',
                dados.prioridade || 'normal',
                JSON.stringify(dados)
            ]
        );

        logger.info('Atendimento criado', {
            id: result.insertId,
            registro,
            usuario: req.user.username,
            tenant: req.tenant.nome_organizacao
        });

        res.json({
            sucesso: true,
            mensagem: 'Atendimento criado com sucesso',
            id: result.insertId,
            registro: registro
        });

    } catch (error) {
        logger.error('Erro ao criar atendimento', { error: error.message });
        res.status(500).json({ error: 'Erro ao criar atendimento' });
    }
});

// Atualizar atendimento
app.put('/api/atendimentos/:id', identifyTenant, authenticateToken, async (req, res) => {
    try {
        const dados = req.body;
        const connection = await getConnection();

        const [result] = await connection.query(
            `UPDATE atendimentos SET
                data_atendimento = ?,
                hora_atendimento = ?,
                nome_completo = ?,
                cpf = ?,
                telefone = ?,
                data_nascimento = ?,
                tecnico_responsavel = ?,
                tipo_atendimento = ?,
                unidade = ?,
                status = ?,
                prioridade = ?,
                dados_completos = ?
            WHERE id = ? AND tenant_id = ?`,
            [
                dados.dataAtendimento || null,
                dados.horaAtendimento || null,
                dados.nomeCompleto,
                dados.cpf,
                dados.telefone,
                dados.dataNascimento || null,
                dados.tecnicoResponsavel,
                dados.tipoAtendimento,
                dados.unidade,
                dados.status,
                dados.prioridade,
                JSON.stringify(dados),
                req.params.id,
                req.tenantId
            ]
        );

        if (result.affectedRows === 0) {
            return res.status(404).json({ error: 'Atendimento n√£o encontrado' });
        }

        logger.info('Atendimento atualizado', {
            id: req.params.id,
            usuario: req.user.username,
            tenant: req.tenant.nome_organizacao
        });

        res.json({ sucesso: true, mensagem: 'Atendimento atualizado' });

    } catch (error) {
        logger.error('Erro ao atualizar atendimento', { error: error.message, id: req.params.id });
        res.status(500).json({ error: 'Erro ao atualizar atendimento' });
    }
});

// Deletar atendimento
app.delete('/api/atendimentos/:id', identifyTenant, authenticateToken, async (req, res) => {
    try {
        const connection = await getConnection();
        const [result] = await connection.query(
            'DELETE FROM atendimentos WHERE id = ? AND tenant_id = ?',
            [req.params.id, req.tenantId]
        );

        if (result.affectedRows === 0) {
            return res.status(404).json({ error: 'Atendimento n√£o encontrado' });
        }

        logger.info('Atendimento exclu√≠do', {
            id: req.params.id,
            usuario: req.user.username,
            tenant: req.tenant.nome_organizacao
        });

        res.json({ sucesso: true, mensagem: 'Atendimento exclu√≠do' });

    } catch (error) {
        logger.error('Erro ao deletar atendimento', { error: error.message, id: req.params.id });
        res.status(500).json({ error: 'Erro ao deletar atendimento' });
    }
});

// ==========================================
// ROTAS MODULARES (COM TENANT) - TODAS MANTIDAS
// ==========================================

// Aplicar rate limiting para APIs
app.use('/api/', apiLimiter);

// Rotas principais com /api
app.use('/api/estoque', identifyTenant, authenticateToken, estoqueRoutes);
app.use('/api/agenda', identifyTenant, authenticateToken, agendaRoutes);
app.use('/api/admin', identifyTenant, authenticateToken, adminRoutes);

// ‚úÖ Rota de tenants (Super Admin apenas) - COM VALIDA√á√ÉO
app.use('/api/admin/tenants', authenticateToken, authenticateSuperAdmin, tenantsRoutes);

// Rotas legacy (para compatibilidade) - MANTIDAS
app.use('/estoque', identifyTenant, authenticateToken, estoqueRoutes);
app.use('/eventos', identifyTenant, authenticateToken, agendaRoutes);
app.use('/agendamentos', identifyTenant, authenticateToken, agendaRoutes);

// Carregar rotas dinamicamente - MANTIDO EXATAMENTE COMO ESTAVA
const routesToLoad = [
    { path: '/api/atividades', file: './src/routes/atividades', name: 'atividades' },
    { path: '/api/permissoes', file: './src/routes/permissoes', name: 'permiss√µes' },
    { path: '/api/usuarios', file: './src/routes/usuarios', name: 'usuarios' },
    { path: '/api/profissionais', file: './src/routes/profissionais', name: 'profissionais' },
    { path: '/api/estatisticas', file: './src/routes/estatisticas', name: 'estat√≠sticas' },
    { path: '/api/beneficios', file: './src/routes/beneficios', name: 'benef√≠cios' }
];

routesToLoad.forEach(route => {
    try {
        const routeModule = require(route.file);
        app.use(route.path, identifyTenant, authenticateToken, routeModule);

        // Adicionar rotas legacy se for benef√≠cios
        if (route.name === 'benef√≠cios') {
            app.use('/beneficios', identifyTenant, authenticateToken, routeModule);
        }

        logger.info(`Rota ${route.name} carregada com sucesso`);
    } catch (e) {
        logger.warn(`Rota ${route.name} n√£o encontrada`, { error: e.message });
    }
});

// ==========================================
// TRATAMENTO DE ERROS
// ==========================================

app.use((req, res) => {
    logger.warn('Rota n√£o encontrada', {
        path: req.path,
        method: req.method,
        tenant: req.tenant?.nome_organizacao
    });
    res.status(404).json({
        sucesso: false,
        mensagem: 'Rota n√£o encontrada',
        path: req.path
    });
});

app.use((err, req, res, next) => {
    logger.error('Erro n√£o tratado', {
        error: err.message,
        stack: err.stack,
        path: req.path,
        tenant: req.tenant?.nome_organizacao
    });
    res.status(500).json({
        sucesso: false,
        mensagem: 'Erro interno do servidor',
        error: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
});

// ==========================================
// INICIALIZA√á√ÉO
// ==========================================

async function startServer() {
    try {
        logger.info('Inicializando Sistema CRAS Multi-Tenant...');

        await connectDatabase();

        const PORT = process.env.PORT || 3000;

        const server = app.listen(PORT, '0.0.0.0', () => {
            logger.info('');
            logger.info('=================================================');
            logger.info('  ‚úÖ SERVIDOR MULTI-TENANT RODANDO COM MELHORIAS');
            logger.info('=================================================');
            logger.info('');
            logger.info(`Porta: ${PORT}`);
            logger.info('Sistema: Multi-Tenant (Subdom√≠nios)');
            logger.info('Autentica√ß√£o: JWT');
            logger.info('Cache: Node-Cache (300s TTL)');
            logger.info('Rate Limiting: Ativo');
            logger.info('Compression: Ativo');
            logger.info('M√©tricas: Ativo');
            logger.info('');
            logger.info('URLs de Exemplo:');
            logger.info(`   ‚Ä¢ Demo: http://demo.localhost:${PORT}`);
            logger.info('   ‚Ä¢ Cliente1: http://cliente1.fortalecesuas.com');
            logger.info(`   ‚Ä¢ Health: http://localhost:${PORT}/health`);
            logger.info(`   ‚Ä¢ Metrics: http://localhost:${PORT}/metrics`);
            logger.info('');
            logger.info('API Endpoints:');
            logger.info('   ‚Ä¢ Login: POST /auth/login');
            logger.info('   ‚Ä¢ Verificar: GET /auth/verificar');
            logger.info('   ‚Ä¢ Logout: POST /auth/logout');
            logger.info('   ‚Ä¢ Atendimentos: GET /api/atendimentos');
            logger.info('   ‚Ä¢ Usu√°rios: GET /api/usuarios');
            logger.info('   ‚Ä¢ Benef√≠cios: GET /api/beneficios');
            logger.info('   ‚Ä¢ Tenants (Super Admin): GET /api/admin/tenants');
            logger.info('');
            logger.info('Melhorias Ativas:');
            logger.info('   ‚úì Cache de tenants');
            logger.info('   ‚úì Rate limiting (global + auth + API)');
            logger.info('   ‚úì Compression de respostas');
            logger.info('   ‚úì Logging estruturado');
            logger.info('   ‚úì M√©tricas de performance');
            logger.info('   ‚úì Health check avan√ßado');
            logger.info('   ‚úì CORS corrigido (bloqueio real)');
            logger.info('   ‚úì Seguran√ßa refor√ßada');
            logger.info('   ‚úì Valida√ß√£o Super Admin');
            logger.info('');
            logger.info('=================================================');
        });

        // Graceful shutdown
        const gracefulShutdown = async (signal) => {
            logger.warn(`Recebido sinal ${signal}, iniciando shutdown gracioso...`);

            server.close(async () => {
                logger.info('Servidor HTTP fechado');

                try {
                    // Limpar cache
                    tenantCache.flushAll();
                    logger.info('Cache limpo');

                    // Fechar conex√µes do banco
                    const { closeDatabase } = require('./src/config/database');
                    await closeDatabase();
                    logger.info('Conex√µes do banco fechadas');

                    // Salvar m√©tricas finais
                    const totalRequests = Array.from(requestStats.values())
                        .reduce((sum, stat) => sum + stat.count, 0);
                    logger.info('Estat√≠sticas finais', {
                        totalRequests,
                        uptime: process.uptime()
                    });

                } catch (error) {
                    logger.error('Erro durante shutdown', { error: error.message });
                }

                logger.info('Shutdown completo. At√© logo! üëã');
                process.exit(0);
            });

            // Timeout de seguran√ßa
            setTimeout(() => {
                logger.error('For√ßando shutdown ap√≥s timeout de 10s');
                process.exit(1);
            }, 10000);
        };

        process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
        process.on('SIGINT', () => gracefulShutdown('SIGINT'));

        // Tratar erros n√£o capturados
        process.on('uncaughtException', (error) => {
            logger.error('Exce√ß√£o n√£o capturada', { error: error.message, stack: error.stack });
            gracefulShutdown('uncaughtException');
        });

        process.on('unhandledRejection', (reason, promise) => {
            logger.error('Promise rejeitada n√£o tratada', { reason, promise });
        });

    } catch (error) {
        logger.error('Erro ao inicializar servidor', { error: error.message, stack: error.stack });
        process.exit(1);
    }
}

if (require.main === module) {
    startServer();
}

module.exports = app;







<body>
    <div class="login-box">
        <h2>Login SuperAdmin</h2>
        <form id="superadmin-form">
            <div class="form-group">
                <label>Email ou Usu√°rio</label>
                <input type="text" id="usuario" required>
            </div>
            <div class="form-group">
                <label>Senha</label>
                <input type="password" id="senha" required>
            </div>
            <div class="form-group">
                <label>Chave de Acesso</label>
                <input type="password" id="chave" placeholder="SUPERADMIN_KEY" required>
            </div>
            <button type="submit">Entrar</button>
            <div id="alert" class="alert"></div>
        </form>
    </div>
